[{"title":"快速排序","date":"2018-05-14T06:55:18.000Z","path":"2018/05/14/快速排序/","text":"概念快速排序基于分治思想来实现。 分解：数组A[start,end]被划分为两个（可能为空）子数组A[start,postion-1]和A[postion+1,end]中的,使A[start,postion-1]的每一个元素都小于等于A[postion],A[postion+1,end]的每一个元素都大于等于A[postion]。 解决：通过递归调用快速排序，对子数组A[start,postion-1]和A[postion+1,end]进行排序。 合并：因为数组是原址排序，因此A[start,end]是有序的。 数组的划分（解决）实现思想图 PHP实现快速排序function quickSort(&amp;$array,$start,$end) { if ($start &lt; $end) { $postion = partition($array, $start, $end); quickSort($array,$start,$postion-1); quickSort($array,$postion+1,$end); } } function partition(&amp;$arr,$start,$end) { $flag = $arr[$end]; $i = $start-1; for ( $j=$start; $j&lt;= $end-1; $j++) { if($arr[$j] &lt;= $flag) { $i = $i+1; swap($arr,$i,$j); } } swap($arr,$i+1,$end); return $i+1; } function swap (&amp;$arr,$exist,$replace) { $temp = $arr[$exist]; $arr[$exist] = $arr[$replace]; $arr[$replace] = $temp; } $array = array(1,6,5,4); quickSort($array,0,3); var_dump($array);","tags":[{"name":"排序","slug":"排序","permalink":"http://blog.psonlyweb.cn/tags/排序/"}]},{"title":"优先队列(PriorityQueue)","date":"2018-05-08T03:53:16.000Z","path":"2018/05/08/优先队列PriorityQueue/","text":"概述优先队列（priority queue）是一种用来维护由一组元素构成的集合S的数据结构，其中每一个元素都有一个相关的值，称为关键字（key）。队列的定义队列属于先进先出型，Frist in Frist out（FIFO）优先队列基于堆排序的方法进行实现的，堆排序每次都要进行建立最大堆，第一个元素为整个队列中的最大值，优先队列也是利用了堆排序这个性质达到优先队列中权值最大的先出的效果。 优先队列的方法 HeapMaximum方法实现了返回最大值 HeapExtractMax方法实现删除队列中的最大值并返回最大值 HeapIncreaseKey方法实现更改某个值。 MaxHeapInsert方法实现将元素插入到队列队尾 PHP实现优先队列 public function HeapMaximum($arr) { return $arr[0]; } public function HeapExtractMax(&amp;$arr,$length) { if($length &lt; 1) { return false; } $max = $arr[0]; $arr[0] = $arr[$length-1]; $length = $length - 1; $this-&gt;MaxHeapify($arr,1,$length); return $max; } public function HeapIncreaseKey(&amp;$arr,$i,$key) { if ($key &lt; $arr[$i]) { return false; } $arr[$i] = $key; $flag = $this-&gt;parent($i); while ($i &gt; 1 &amp;&amp; $arr[$flag] &lt; $arr[$i]) { $this-&gt;swap($arr,$flag,$i); $i = $this-&gt;parent($i); } } public function MaxHeapInsert(&amp;$arr,$key) { $length = count($arr) + 1; $arr[$length] = 0; $this-&gt;HeapIncreaseKey($arr,$length,$key); } 基于堆排序的PHP的部分代码class PriorityQueue { public function __construct(&amp;$arr) { $arr_length = count($arr)-1; $this-&gt;BuildMaxHeap($arr,$arr_length); } public function BuildMaxHeap(&amp;$arr,$arr_length) { $count = count($arr)-1; for ($i = floor($count/2); $i &gt;=0; $i--) { $this-&gt;MaxHeapify($arr,$i,$arr_length); } } public function MaxHeapify(&amp;$arr,$i,$arr_length) { $left = $this-&gt;left($i); $right = $this-&gt;right($i); if($left &lt;= $arr_length &amp;&amp; $arr[$left] &gt;= $arr[$i]) { $this-&gt;swap($arr,$i,$left); $largest = $left; } else { $largest = $i; } if ($right &lt;= $arr_length &amp;&amp; $arr[$right] &gt;= $arr[$largest]) { $this-&gt;swap($arr,$largest,$right); $largest = $right; } if ($largest != $i) { $this-&gt;MaxHeapify($arr,$largest); } } public function swap(&amp;$arr,$exist,$largest) { $temp = $arr[$exist]; $arr[$exist] = $arr[$largest]; $arr[$largest] = $temp; } private function left($i) { return 2*$i+1; } private function right($i) { return 2*$i+2; } private function parent($i) { return floor($i/2); } //以下是队列操作 }","tags":[{"name":"队列","slug":"队列","permalink":"http://blog.psonlyweb.cn/tags/队列/"}]},{"title":"网络分层TCP/IP","date":"2018-05-07T02:41:46.000Z","path":"2018/05/07/网络分层TCP-IP/","text":"概述互联网分为五层，自下而上分为应用层、传输层、网络层、链接层、实体层。 实体层实体层就是把电脑连接在一起的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 链接层拥有唯一的MAC地址进行标识，有了数据包和网卡MAC地址、广播的发送方式，链路层就可以在多台计算机之间传送数据。 网络层网络层关心的是如何把一个数据从一台设备发送到另一台设备。是主机到主机之间的通信。 传输层有了MAC地址和IP地址，我们可以在互联网任意两个主机上建立通信。区分一台主机中的接收的数据包属于哪个程序使用，是靠端口判断的。传输层的功能是从端口到端口的通信。因此Unix系统就把主机和端口叫作套接字(socket) UDP协议UDP数据包，也是由”标头”和”数据”两部分组成。“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： TCP协议UDP协议的优点是比较简单，容易实现，但是缺点是可靠性差，一旦数据发出后，无法知道对方是否收到。为了解决这个问题，TCP协议诞生。TCP协议可以理解为有确认机制的UDP协议。如果发送一个数据包遗失，就收不到确认，发送方就知道有必要重新发送数据包。而且TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络效率通常TCP数据包的长度不会超过IP数据包长度，以保证单个TCP数据包不被分割。 应用层应用层的作用就是规定应用程序的数据格式。TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP。必须有不同的协议规定电子邮件、网页、FTP数据格式，这些应用程序协议构成了“应用层”。","tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://blog.psonlyweb.cn/tags/TCP-IP/"}]},{"title":"堆排序","date":"2018-05-04T03:06:56.000Z","path":"2018/05/04/堆排序/","text":"堆排序概念堆排序是利用堆这种数据结构而设计的一种排序算法。时间复杂度为O(nlogn)。 堆排序具有如下性质的完全二叉树:每个节点的值都大于或等于其左右孩子节点的值，称为最大堆；或每个节点都小于或者等于其左右孩子节点被称为最小堆。 对堆中的节点进行编号，将这种逻辑映射到数组中，如下： 堆排序的基本性质：最大堆：左右子节点小于父节点最小堆：左右子节点大于父节点 堆排序流程1.构建最大堆构建最大堆之前呈现效果如下： 构建最大堆之后呈现效果如下： 保证了堆排序中的最大堆的性质。2.堆排序算法实现取出构建最大堆中的最大值，放在尾部然后重新构建最大堆。 以此类推最终达到从小到大的排序效果，完成堆排序。 PHP实现堆排序&lt;?php /** * */ class HeapSort { public function __construct(&amp;$arr) { $arr_length = count($arr)-1; $this-&gt;HeapMaxSort($arr,$arr_length); } private function HeapMaxSort(&amp;$arr,$arr_length) {; $this-&gt;BuildMaxHeap($arr,$arr_length); for($i = $arr_length;$i &gt;= 0; $i--) { $this-&gt;swap($arr,$i,0); $arr_length--; $this-&gt;MaxHeapify($arr,0,$arr_length); } } private function BuildMaxHeap(&amp;$arr,$arr_length) { $count = count($arr)-1; for ($i = floor($count/2); $i &gt;=0; $i--) { $this-&gt;MaxHeapify($arr,$i,$arr_length); } } public function MaxHeapify(&amp;$arr,$i,$arr_length) { $left = $this-&gt;left($i); $right = $this-&gt;right($i); if($left &lt;= $arr_length &amp;&amp; $arr[$left] &gt;= $arr[$i]) { $this-&gt;swap($arr,$i,$left); $largest = $left; } else { $largest = $i; } if ($right &lt;= $arr_length &amp;&amp; $arr[$right] &gt;= $arr[$largest]) { $this-&gt;swap($arr,$largest,$right); $largest = $right; } if ($largest != $i) { $this-&gt;MaxHeapify($arr,$largest); } } public function swap(&amp;$arr,$exist,$largest) { $temp = $arr[$exist]; $arr[$exist] = $arr[$largest]; $arr[$largest] = $temp; } private function left($i) { return 2*$i+1; } private function right($i) { return 2*$i+2; } } $array = array(5,2,3,1,4,6); $Heap_Model = new HeapSort($array); var_dump($array);","tags":[{"name":"排序","slug":"排序","permalink":"http://blog.psonlyweb.cn/tags/排序/"}]},{"title":"最大子数组","date":"2018-04-26T09:47:41.000Z","path":"2018/04/26/最大子数组/","text":"暴力求解最大子数组function violentMax($array,$count,&amp;$start,&amp;$end) { $sum = 0; $max = 0; for($i=0; $i &lt;= $count-1; $i++) { for ($j = $i; $j &lt;= $count-1 ; $j++) { $sum = 0; for($k = $i; $k &lt;= $j; $k++) { $sum += $array[$k]; } if ($sum &gt; $max) { $start = $i; $end = $j; $max = $sum; } } } return $max; } $array = array(3,-1,2,5,-3,4,-6,-7,1,8,-3,5,9); $count = count($array); $start = 0; $end = 0; $max = violentMax($array,$count,$start,$end); echo &#39;&lt;hr&gt;&#39;; echo $start; echo &#39;&lt;hr&gt;&#39;; echo $end; echo &#39;&lt;hr&gt;&#39;; echo $max; 上面方法的时间复杂度为O( n^2 ); 分治策略实现最大子数组&lt;?php class divideRule { public $left_pos; public $right_pos; public function divide($arr,$start,$end) { if ($start == $end) { return $arr[$start]; } else { $mid = floor(($start+$end)/2); $left_max = $this-&gt;divide($arr,$start,$mid); $right_max = $this-&gt;divide($arr,$mid+1,$end); $middle_max = $this-&gt;middleMax($arr,$start,$mid,$end); if ($left_max &gt;= $right_max &amp;&amp; $left_max &gt;= $middle_max) { return $left_max; } else if($right_max &gt;= $left_max &amp;&amp; $right_max &gt;= $middle_max) { return $right_max; } else { return $middle_max; } } } public function middleMax($arr,$start,$mid,$end) { $left_sum = 0; $sum = 0; for($i = $mid; $i &gt;= 0; $i--) { $sum = $sum + $arr[$i]; if ($sum &gt; $left_sum) { $left_sum = $sum; $this-&gt;left_pos = $i; } } $right_sum = 0; $sum = 0; for ($j = $mid+1; $j &lt;= $end ; $j++) { $sum = $sum + $arr[$j]; if ($sum &gt; $right_sum) { $right_sum = $sum; $this-&gt;right_pos = $j; } } $count_sum = $right_sum + $left_sum; return $count_sum; } } $array = array(3,-1,2,5,-3,4,-6,-7,1,8,-3,5,9); $count = count($array)-1; $rule_class = new divideRule(); $max = $rule_class-&gt;divide($array,0,$count); echo $rule_class-&gt;left_pos; echo $rule_class-&gt;right_pos; var_dump($max);","tags":[{"name":"最大子数组","slug":"最大子数组","permalink":"http://blog.psonlyweb.cn/tags/最大子数组/"}]},{"title":"归并排序","date":"2018-04-25T03:27:46.000Z","path":"2018/04/25/归并排序/","text":"PHP实现归并排序算法&lt;?php function merger_sort(&amp;$arr,$frist,$end) { if($frist &lt; $end) { $middle = floor(($frist+$end)/2); merger_sort($arr,$frist,$middle); merger_sort($arr,$middle+1,$end); merger($arr,$frist,$middle,$end); } } function merger(&amp;$arr,$start,$mid,$end) { $i = $start; $j=$mid + 1; $k = $start; $temparr = array(); while($i!=$mid+1 &amp;&amp; $j!=$end+1) { if($arr[$i] &gt;= $arr[$j]){ $temparr[$k++] = $arr[$j++]; } else{ $temparr[$k++] = $arr[$i++]; } } while($i != $mid+1){ $temparr[$k++] = $arr[$i++]; } while($j != $end+1){ $temparr[$k++] = $arr[$j++]; } for($i=$start; $i&lt;=$end; $i++){ $arr[$i] = $temparr[$i]; } } function MergeSort(&amp;$arr){ $start = 0; $end = count($arr) - 1; merger_sort($arr,$start,$end); } $array = array(5,2,7,4); MergeSort($array); var_dump($array); 分治策略的步骤 分解 原问题为若干个子问题,这些子问题是原问题的规模较小的实例。 解决 这些子问题，递归地求解各子问题。然而子问题的规模足够小，则直接求解。 合并 这些子问题的解成原问题的解。 归并排序遵从分治策略 merger_sort函数完成了分解的步骤，将原数组array(5,2,7,4)最终分解为array(5,2)和array(7,4) merger函数完成了解决（排序）和合并的操作首先对分解的array(5,2)和array(7,4)进行排序，得到 array(2,5)和array(4,7),然后合并为array(2,5,4,7),然后继续merge进行解决，流程是将2与4进行比较拿出较小的放在原数组中，然后将4和5进行比较，然后比较5和7，完成归并排序。 总结归并排序的时间复杂度是o(nlogn)","tags":[{"name":"排序","slug":"排序","permalink":"http://blog.psonlyweb.cn/tags/排序/"}]},{"title":"模型工厂","date":"2018-02-28T09:53:56.000Z","path":"2018/02/28/模型工厂/","text":"目的实际项目开发中我们经常会用到一些假数据来对数据库进行填充以方便调试程序,原始的做法是手工的一个个在数据创建。Laravel提供了一套更加现代化、非常简单易用的数据填充方案。接下来让我们使用Laravel提供的数据填充来批量生成一批假数据。假数据的生成分为两个阶段：1.对要生成假数据的模型指定字段进行赋值- {模型工厂}2.批量生成假数据模型 - {数据填充} 模型工厂Laravel默认集成了Faker扩展包，使用该扩展包可以方便我们生成一些假数据。示例如下： //使用factory 来创建一个Faker\\Generator实例 $faker = Faker\\Factory::create(); $faker-&gt;name; $faker-&gt;safeEmail; $faker-&gt;date; $faker-&gt;time; 借助Faker和Eloquent模型工厂来为指定模型的每个字段设置随机值。Laravel生成模型工厂php artisan make:factory UserFactory实例UserFactory如下： &lt;?php use Faker\\Generator as Faker; /* |-------------------------------------------------------------------------- | Model Factories |-------------------------------------------------------------------------- | | This directory should contain each of the model factory definitions for | your application. Factories provide a convenient way to generate new | model instances for testing / seeding your application&#39;s database. | */ $factory-&gt;define(App\\Models\\User::class, function (Faker $faker) { static $password; return [ &#39;name&#39; =&gt; $faker-&gt;name, &#39;email&#39; =&gt; $faker-&gt;unique()-&gt;safeEmail, &#39;password&#39; =&gt; $password ?: $password = bcrypt(&#39;secret&#39;), &#39;remember_token&#39; =&gt; str_random(10), ]; }); define定义了一个指定数据模型(如此例子User)的模型工厂。define方法接收两个参数,第一个参数指定的Eloquent模型类,第二个参数为一个闭包函数，该闭包函数接受一个FakerPHP函数库的实例，让我们可以在函数内部使用Faker方法生成假数据。 数据填充Laravel中我们使用Seeder类来给数据库填充测试数据。所有seeder类在database/seeds，文件名需要按照【驼峰式】来命名,且严格遵循大小写规范。Laravel默认定义了DatabaseSeeder类，可在该类中使用call方法来运行其他的Seeder类，以此控制数据填充的顺序。我们可以使用如下命令生成 UserTableSeeder文件。$ php artisan make:seeder UserTableSeeder定义好模型工厂后,在UserTableSeeder中使用factory方法来生成一个使用假数据的用户对象。 &lt;?php use Illuminate\\Database\\Seeder; use App\\Models\\User; class UserSeeder extends Seeder { /** * Run the database seeds. * * @return void */ public function run() { // $user = factory(User::class); User::insert($user-&gt;makeVisible([&#39;password&#39;,&#39;remember_token&#39;])); $user = User::find(1); $user-&gt;name = &#39;PS&#39;; $user-&gt;email = &#39;ps@qq.com&#39;; $user-&gt;password = bcrypt(&#39;password&#39;); $user-&gt;save(); } } 最后一步 在DatabaseSeeder中调用call方法来指定我们要运行假数据填充的文件。 &lt;?php use Illuminate\\Database\\Seeder; use Illuminate\\Database\\Eloquent\\Model; class DatabaseSeeder extends Seeder { /** * Run the database seeds. * * @return void */ public function run() { // $this-&gt;call(UsersTableSeeder::class); Model::unguard(); $this-&gt;call(UserSeeder::class); Model::reguard(); } } 运行命令重置数据库，执行数据填充 $ php artisan migrate:refresh $ php artisan db:seed 单独执行某个UserSeeder文件如下： $ php artisan migrate:refresh $ php artisan db:seed --class=UserSeeder 一条命令同时完成数据库重置和填充操作: $ php artisan migrate:refresh --seed","tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.psonlyweb.cn/tags/Laravel/"}]},{"title":"npm相关","date":"2018-02-27T01:16:43.000Z","path":"2018/02/27/npm相关/","text":"npm命令 命令 说明 npm run dev 编译 npm run watch-poll 当文件发生变化时自动编译 npm install 安装第三方模块(扩展包) npm install -f 检查是否安装 如果已安装则跳过安装 sass语法基础1.样式文件导入Sass使用 @import来导入其他的样式文件。2.变量Sass 允许在代码中添加变量，所有变量均以$开头3.嵌套Sass 允许代码之间相互嵌套，以减少代码量 body div { color: red } body h1 { margin-top: 10px } //可写成 body { div{ color:red } h1 { margin-top:10px } } 4.引用父级选择器Sass嵌套中使用&amp;对父选择器进行引用 a { color:white; } a:hover { color:blue; } a { color: white; &amp;:hover { color:blue; } }","tags":[{"name":"npm","slug":"npm","permalink":"http://blog.psonlyweb.cn/tags/npm/"}]},{"title":"git","date":"2018-02-26T01:19:00.000Z","path":"2018/02/26/git/","text":"git的基本设置//设置用户名 git config --global user.name &quot;Your Name&quot; //设置邮箱 git config --global user.email 786188095@qq.com //git 推送分支时的相关配置 git config --global push.default simple git项目初始化//对Git进行初始化 $ cd ~/Code/Laravel $ git init //将项目所有文件纳入到Git中 $ git add -A //检查git状态 $ git status //保留改动并提交 $ git commit -m “说明内容” // 查看历史提交记录 $ git log git上传github Repository将SSH Key添加到ssh-agent中 eval &quot;$(ssh-agent -s)&quot; ssh-add ~/.ssh/id_rsa //添加github地址 $ git remote add origin git@github.com:your_username/hello_laravel.git //将修改提交至github中 $ git push -u origin master git命令 命令 说明 git add -A 添加本地库 git commit -m “说明信息” 提交 git push 分支名称 上传至线上版本 git branch 分支名称 创建分支 git checkout 分支名称 切换分支 git checkout -b 分支名称 创建并切换分支 git merge 分支 合并分支 git pull 将线上的文件拉取到本地","tags":[{"name":"git","slug":"git","permalink":"http://blog.psonlyweb.cn/tags/git/"}]},{"title":"Laravel学习笔记","date":"2018-02-08T03:04:07.000Z","path":"2018/02/08/Laravel学习笔记/","text":"任务管理内容任务 Taskartisan make:model Task -m -m 生成数据库迁移文件工程 Projectartisan make:model Project -m用户 User理解需求：一个用户可以拥有多个Project一个用户通过Project可以拥有多个TaskUser.php public function projects() { return $this-&gt;hasMany(&#39;App\\Project&#39;); } public function tasks() { return $this-&gt;hasManyThrough(&#39;App\\Task&#39;,&#39;App\\Project&#39;); } 一个Project必定属于一个用户一个Project拥有多个TaskProject.php public function user() { return $this-&gt;belongsTo(&#39;App\\User&#39;); } public function tasks() { return $this-&gt;hasMany(&#39;App\\Task&#39;); } 一个任务Task必定属于一个ProjectTask.php public function project() { return $this-&gt;belongsTo(&#39;App\\Project&#39;); } Laravel模型关系表 定义关联关系 定义 调用 一对一 hasOne User::find(1)-&gt;phone 一对多 hasMany App\\Post::find(1)-&gt;comments 多对多 belongsToMany App\\User::find(1) foreach ($user-&gt;roles 远层的一对多 hasManyThrough 多态关联 morphMany 多对多的多态关联 morphToMany 数据表设计与数据表迁移 public function up() { Schema::create(&#39;tasks&#39;, function (Blueprint $table) { $table-&gt;increments(&#39;id&#39;); $table-&gt;string(&#39;title&#39;); $table-&gt;integer(&#39;project_id&#39;); $table-&gt;boolean(&#39;completed&#39;); $table-&gt;timestamps(); }); } 设计数据表之后执行php artisan migrate artisan常用命令 artisan make:auth 生成登录注册代码 artisan make:model Project -m 生成model artisan migrate 生成数据表 artisan migrate:rollback 撤销刚刚生成的数据表 artisan make:controller ProjectController 生成Controller 加上–resource可生成基础的方法 增删改查 artisan make:request CreateProjectRequest 验证表单数据 artisan make:policy 授权策略文件名称 生成授权策略文件 laravel组件安装Form &amp; Html 组件composer require &quot;laravelcollective/html&quot;:&quot;^5.4.0&quot; 图片上传组件 composer require intervention/image 在config/app.php里$providers里添加Intervention\\Image\\ImageServiceProvider::class 在$aliases里添加&#39;Image&#39; =&gt; Intervention\\Image\\Facades\\Image::class php artisan vendor:publish --provider=&quot;Intervention\\Image\\ImageServiceProviderLaravel5&quot; 生成image的配置文件 添加语言包1.使用composer require &quot;overtrue/laravel-lang:~3.0&quot;2.config/app.php &lt;?php return [ . . . &#39;locale&#39; =&gt; &#39;zh-CN&#39;, . . . ];","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.psonlyweb.cn/tags/PHP/"},{"name":"笔记","slug":"笔记","permalink":"http://blog.psonlyweb.cn/tags/笔记/"}]},{"title":"laravel目录","date":"2018-02-07T09:48:56.000Z","path":"2018/02/07/laravel目录/","text":"文件夹结构表1.1：Laravel文件夹结构简介 文件夹名称 简介 app 应用程序的业务逻辑代码存放文件夹 app/Console 存放自定义Artisan命令文件 app/Http/Controllers 存放控制器文件 app/Http/Middleware 存放[中间件]文件 bootstrap 框架启动与自动加载设置相关的文件 composer.json 应用依赖的扩展包 composer.lock 扩展包列表，确保这个应用的副本 config 应用程序的配置文件 database 数据库操作相关文件 node_modules 存放npm依赖模块 package.json 应用所需的NPM包配置文件 phpunit.xml 测试工具PHPUnit的配置文件 public 前端控制和资源相关文件(图片、JavaScript、CSS) resource 应用资源 resourse/assets 未编译的应用资源文件（图片、JavaScript、CSS） resource/lang 多语言文件 resource/views 视图文件 routes/api.php 用于定义API类型的路由 routes/channels.php 事件转播注册信息 routes/console.php 用于定义Artisan命令 server.php 使用PHP内置服务器时的URL重写（类似于Apache的“mod_rewrite”） storage 编译后的视图、基于会话、文件缓存和其他框架生成的文件 storage/app 目录可用于存储应用程序的任何文件 storage/framework 目录被用于保存框架生成的文件及缓存 storage/logs 应用程序的日志文件 tests 应用测试相关文件 vendor Composer依赖模块 webpack.mix.js Laravel的前端工作流配置文件 yarn.lock Yarn依赖版本锁定文件 .env 环境变量配置文件","tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.psonlyweb.cn/tags/Laravel/"}]},{"title":"laravel常见错误","date":"2018-02-07T01:39:37.000Z","path":"2018/02/07/laravel常见错误/","text":"错误1问题:使用laravel框架时 出现No supported encrypter found. The cipher and / or key length are invalid原因：因为需要配置config/app.php里面的key的值解决方法: php artisan key:generate","tags":[]},{"title":"SplDoublylinkedList双向链表","date":"2018-02-06T02:46:42.000Z","path":"2018/02/06/SplDoublylinkedList双向链表/","text":"SplDoublyLinkedList相关方法 rewind 使链表的当前指针指向链表的底部(头部) push 向链表的顶部(尾部)插入一个节点 pop: 获取链表中的顶部(尾部)节点，并且从链表中删除这个节点；操作不改变当前指针的位置 current指向链表当前节点的指针，必须调用之前先调用rewind。当指向的节点被删除之后，会指向一个空节点。(使用current方法之前首先判断节点是否有效 valid方法进行判断) next 让链表当前节点的指针指向下一节点，current的返回值随之改变 unshift 向链表的底部(头部)插入一个节点 shift 删除一个链表底部(头部)节点 bottom 获得链表底部(头部)元素，当前指针位置不变 top: 获得链表顶部（尾部）元素，当前指针位置不变","tags":[{"name":"SPL","slug":"SPL","permalink":"http://blog.psonlyweb.cn/tags/SPL/"}]},{"title":"Socket通信编程","date":"2018-02-01T09:41:21.000Z","path":"2018/02/01/Socket通信编程/","text":"##Socket连接过程 服务器监听：服务端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此客户端的套接字必须首先描述它所要连接的服务器的套接字，并给出服务器端的套接字的地址和端口号，然后向服务器端提出连接请求。 连接确认：当服务器端套接字监听或者接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端的套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接受其他客户端套接字的连接请求。 PHP安全XSS防御 转义/编码 htmlspecialchars() 过滤 strip_tags CSP(Content Security Policy) 第三方库 HTML purifier htmLawed Zend_Filter_Input 会话攻击防御 session_regenerate_id() 二级令牌 检测UA和用户IP","tags":[]},{"title":"PHP异步并行","date":"2018-02-01T02:33:59.000Z","path":"2018/02/01/PHP异步并行/","text":"一个PHP Web程序的执行过程 请求开始 (GET/Post/Cookie/Session) Mysql数据库查询/Redis查询 模板渲染输出HTML/json_encode 请求结束(回收所有内存和资源) PHP-FPM进程的完整流程 请求1 处理请求 发送响应 请求2 处理请求 发送响应 请求3 处理请求 发送响应 。。。。 Accept-&gt;Recv(处理)-&gt;Send-&gt;Close-&gt;Accept-&gt;Recv-&gt;Send-&gt;Close 多进程并发地处理请求 进程1 请求1-&gt;请求2-&gt;……-&gt;请求N 进程2 进程3 … 进程N 扩展 stream sockets libevent/event pcntl/posix pthread sysvsem/sysvmsg shmop/sysvshm PHP同步阻塞$serv = stream_socket_server(&quot;tcp://0.0.0.0:8000&quot;,$errno,$errstr) or die (&quot;服务创建失败&quot;); for ($i=0; $i&lt;32 ;$i++) { if (pcntl_fork() == 0) { while(1) { $conn = stream_socket_accept($serv); $request = fread($conn); $response = &quot;Hello 异步并行&quot;; fwrite($response); fclose($conn); } exit(0); } } 安装Swoole扩展下载稳定版或者最新版的Swoolewget https://github.com/swoole/swoole-src/archive/v1.9.1-stable.tar.gz tar -xzvf v1.9.1-stable.tar.gz cd swoole-src-1.9.1-stable 编译安装phpize ./configure sudo make sudo make install // swoole的./configure有很多额外参数，可以通过./configure --help命令查看,这里均选择默认项) 加入swoole.so扩展到php.ini中//简单的方式1 直接在php.ini文件中加入 extension=swoole.so //方式2 在mods-available文件中创建 对应的ini文件 cd mods-available sudo touch swoole.ini sudo vim swoole.ini //在文件中加入 添加extension=swoole.so sudo ln -s /etc/php5/mods-available/swoole.ini /etc/php5/fpm/conf.d/swoole.ini sudo ln -s /etc/php5/mods-available/swoole.ini /etc/php5/cli/conf.d/swoole.ini //最后重启php-fpm 和 nginx配置完成 php -m 查看扩展是否安装成功","tags":[]},{"title":"Vagrant使用","date":"2018-01-26T08:50:16.000Z","path":"2018/01/26/Vagrant/","text":"Vagrant常用命令 vagrant box list 查看目前已有的box vagrant box add 新增一个box vagrant box remove 删除指定的box vagrant init 初始化配置vagrantfile vagrant up 启动虚拟机 vagrant ssh ssh登录虚拟机 vagrant suspend 挂起虚拟机 vagrant reload 重启虚拟机 vagrant half 关闭虚拟机 vagrant status 查看虚拟机状态 vagrant destroy 删除虚拟机 对虚拟机的优化 替换源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak #备份源文件 sudo vim /etc/apt/source.list #修改源 sudo apt-get update #更新列表 源内容如下： deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 安装Apache Nginx PHPsudo apt-get install 对应名称对应名称 -v 可以查看版本号 Apache更改端口，将端口设置为8888 修改 ports.conf 文件 curl -I ‘http://127.0.0.1:8888‘ Mysql 安装 sudo apt-get install mysql-server #服务器端 安装期间会提示输入为mysql设置root密码，我这边不操作，直接enter 不设置密码 sudo apt-get install mysql-client #客户端 mysql -uroot -p #测试连接库，上面安装服务端没有设置密码，这里直接enter进入 php扩展 sudo apt-get install 名称 php5-mcrypt php5-mysql php5-gd 支持apache2的php sudo apt-get install libapache2-mod-php5 开启rewrite功能 sudo a2enmod rewrite支持nginx fastcgi sudo apt-get install php5-cgi php5-fpm 修改成9000端口 ，默认sock模式 cd /etc/php5/fpm/pool.d sudo vim www.conf # search listen = 127.0.0.1:9000 sudo /etc/init.d/php5-fpm restart ##Vagrant高级知识 端口转发 config.vm.network &quot;forwarded_port&quot;, guest: 8888, host: 8889 共享文件夹config.vm.synced_folder &quot;/Users/ps/www&quot;,&quot;/home/www&quot;,:nfs=&gt;true 私有网络设置 config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot; 虚拟机优化 虚拟机名称 vb.name = &quot;ubuntu_ps&quot; 虚拟机主机名 config.vm.hostname = &quot;ps&quot; 配置虚拟机内存和CPU vb.memory = &quot;1024&quot; vb.cpus = 2 打包分发1.打包vagrant package –output xxx.boxvagrant package –output xxx.box –base 虚拟机名称","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.psonlyweb.cn/tags/Linux/"}]},{"title":"“Mysql优化”","date":"2018-01-26T03:49:35.000Z","path":"2018/01/26/Mysql优化/","text":"建表原则 定长与变长相分离 常用字段和不常用字段要分离 1对多，需要关联统计的字段上，添加冗余字段(空间和时间上的转换) 列选择原则 字段类型优先级 整形 &gt; date,time &gt; enum,char &gt; varchar &gt; blob,text time 定长,运算快，节省空间,考虑时区，写sql时不方便 where &gt; ‘2005-10-12’;enum 能起到约束值的目的，内部用整形来存储char 定长 需要考虑字符集和(排序校对集)varchar 不定长 要考虑字符集的转换与排序时校对集，速度慢text/Blob 无法使用内存临时表（排序等操作只能在磁盘上进行） 够用就行，不要慷慨 原因：大的字段浪费内存，影响速度以年龄为例，tinyint unsigned not null 可以存储255岁,足够使用 ,用int浪费了3个字节以varchar(10) 和 varchar(300) 存储的内容相同，但是在表的联查上varchar(300)要花费更多的内存。 尽量避免使用NULL 原因：NULL 不利于索引 要用特殊字节来标注 索引索引的类型 索引类型分为bTree索引和hash索引 btree 索引原理 二叉树 hash索引 在memory里，默认是hash索引，hash索引的理论上时间复杂度为O(1)。(拉链算法) btree索引的误区 where 条件常用列上都加上索引(错误) 在多列上建立索引发挥作用，需要满足左前缀要求 以index(a,b,c)为例(注意和顺序有关) 语句 索引是否发挥作用 where a =3 是 只使用了a列 where a=3 and b=5 是 使用了a,b列 where a=3 and b=5 and c=5 是 a,b,c均使用 where c=3 where b=4 否 where a=3 and c=4 a列能发挥索引,c不能 where a=3 and b&gt;10 and c=7 a能利用，b能利用，c不能利用 聚簇索引和非聚簇索引 非聚簇索引 Myisam 索引与数据的关系 Myisam 索引指向行所在磁盘的位置 数据都有自己的地址 数据和索引相互独立 聚簇索引 主键索引 既存索引值，又在叶子中存储行的数据 如果没有主键（primary key），则会Unique key做主键 如果没有unique，则系统生成一个内部的rowid做主键 像innodb中，主键的索引结构中既存储了主键值，又存储了行数据的这样的结构c称为“聚簇索引” 聚簇索引和非聚簇索引的优缺点 优势：根据主键查询条目比较少，不用回行(数据就在主键节点下) 劣势: 如果碰到不规则数据插入时会造成频繁的页分裂。####索引覆盖索引覆盖是指查询的列恰好是索引的一部分，那么查询只需要在索引文件上进行，不需要回行到磁盘在查找数据，这样查询速度非常快 理想的索引 查询频繁 区分度高 长度小 尽可能覆盖常用字段 SQL语句优化 提高查询速度的方法 查询的快，联合索引的顺序，区分度，长度 取得快，采用索引覆盖 传输的少，更少的行和列 切分查询： 按数据拆分多次例如：插入10000行数据，每1000条为单位插入 分解查询将逻辑把多表连接查询分解成多个简单的sql sql语句的优化思路不查 -&gt; 少查 -&gt; 高效的查 不查，通过业务逻辑来计算2.少查 尽量精准数据，少取行3.必须要查 尽量在索引上查询 explain 的列分析id 代表select语句的编号 select_type类型 简单查询 SIMPLE 子查询派生子查询 PRIMARY 主语句 subquery 非from子查询 derived from子查询 union union result table 表名key使用的索引列type查数据过程的重要依据可选项 all 意味着从表的第一行，往后逐行做全表扫描 index 扫描所有的索引节点 range 查询 const ref 通过索引列,可以直接引用某行数据ref连接查询 表之间的引用关系rows估计要扫描多少行extraindex:是指用到了索引覆盖效率非常高using where 是光靠索引定位不了还得where判断一下using temporary 是指用到了临时表using filesort 文件排序注:如果取出的列含有text，filesort会发生在磁盘上","tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://blog.psonlyweb.cn/tags/Mysql/"}]},{"title":"设计模式之装饰器模式","date":"2018-01-02T03:07:37.000Z","path":"2018/01/02/设计模式之装饰器模式/","text":"文章类获取初始的文章内容 class Art { protected $content = null; public function __construct($content) { $this-&gt;content = $content; } public function decorator() { return $this-&gt;content; } } 定义装饰文章类art 参数 保存着 文章类的初始化对象 class ArtDesc extends Art { protected $art = null; public function __construct($art) { $this-&gt;art = $art; } public function decorator() { } } SEO类和AD类继承装饰器类达到对文章内容的添加的效果 class SeoArt extends ArtDesc { public function decorator() { return $this-&gt;art-&gt;decorator().&#39;SEO KEYWORDS&#39;; } } class AdArt extends ArtDesc { public function decorator() { return $this-&gt;art-&gt;decorator().&#39;广告内容&#39;; } } 调用将初始化文章基础对象 传入装饰器类 $art = new Art(&#39;文章内容&#39;); $art = new SeoArt($art); $art = new AdArt($art); echo $art-&gt;decorator();","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.psonlyweb.cn/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.psonlyweb.cn/tags/设计模式/"}]},{"title":"设计模式之策略模式","date":"2018-01-02T02:01:34.000Z","path":"2018/01/02/设计模式之策略模式/","text":"设计模式之策略模式 面向对象中有什么比是什么更灵活 组合比继承更灵活 饭店和厨师的关系 是 一对多 比如新开饭店 如果单纯的复制饭店 这样不能会造成很多浪费的方法 但是如果以饭店拥有厨师的方式处理 那么 饭店的样式可以随机变换，因此首先声明一个饭店类 class FD { protected $tangCreator = null; protected $caiCreator = null; protected $fanCreator = null; public function __construct($f,$c,$t) { $this-&gt;fanCreator = $f; $this-&gt;tangCreator = $t; $this-&gt;caiCreator = $c; } public function createFan() { return $this-&gt;fanCreator-&gt;fan(); } public function createCai() { return $this-&gt;caiCreator-&gt;cai(); } public function createTang() { return $this-&gt;tangCreator-&gt;tang(); } } 再声明厨师类 class SouthDinner { public function fan() { return &#39;米饭&#39;; } public function cai() { return &#39;甜食&#39;; } public function tang() { return &#39;蛋花汤&#39;; } } class NorthDinner { public function fan() { return &#39;馒头&#39;; } public function cai() { return &#39;炒菜&#39;; } public function tang() { return &#39;粥&#39;; } } 最后调用 $fd = new FD(new SouthDinner(),new NorthDinner(),new SouthDinner()); echo $fd-&gt;createCai(),&#39;&lt;br&gt;&#39;; echo $fd-&gt;createTang(),&#39;&lt;br&gt;&#39;;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.psonlyweb.cn/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.psonlyweb.cn/tags/设计模式/"}]},{"title":"“设计模式之责任链”","date":"2017-12-29T02:46:17.000Z","path":"2017/12/29/设计模式之责任链/","text":"设计模式之责任链 定义子类首先定义三个类，要声明power权值,以power来判断是否有权利去操作，传过来的数据，还需要声明上一级，责任链模式，要有层级关系 class Banzhu extends Admin { protected $power = 1; protected $top = &#39;Police&#39;; public function doProc() { echo &#39;删帖&#39;; } } class Police extends Admin { protected $power = 2; protected $top = &#39;Guoan&#39;; public function doProc() { echo &#39;抓人&#39;; } } class Guoan extends Admin { protected $power = 3; protected $top = null; public function doProc() { echo &#39;灭口&#39;; } } 定义父类子类均要继承父类方法Admin,Admin的__construct构造方法中，首先判断该类的上一级是否为空,如果是，那么该类是这个责任链中的顶级。 class Admin { public function __construct() { if ($this-&gt;top == null) { return; } $this-&gt;toper = new $this-&gt;top(); } public function proc($danger) { if($danger &lt;= $this-&gt;power) { $this-&gt;doProc(); } else { $this-&gt;toper-&gt;proc($danger); } } } 调用实例化最底层类，然后调用方法传入power $obj = new Banzhu(); $obj-&gt;proc(3);","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.psonlyweb.cn/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.psonlyweb.cn/tags/设计模式/"}]},{"title":"Mysql的事务处理","date":"2017-12-26T09:22:07.000Z","path":"2017/12/26/Mysql的事务处理/","text":"事务的定义：将多条sql操作（增删改）作为一个操作单元，要么都成功，要么都失败Mysql 对事务的支持： –被操作的表必须是InnoDB类型的表（支持事务） –Mysql常用的表类型： MylSAM(非事务)增删改查速度快 InnoDB(事务类型)安全性高 事务处理MYSQL 命令行处理 Mysql&gt; set autocommit =0; Mysql&gt; start transaction; Mysql&gt;commit Mysql&gt;rollbackPDO 事务处理 1、关闭自动提交$pdo -&gt;setattribute(_PDO::ATTRAUTOCOMMIT,0); 2、开启一个事务$pdo -&gt; beginTransaction (); $price =50; $affect_rows=$pdo-&gt;exec(“update demo set ye=ye-{$price} where id=1”);//转出 if($affect_rows){ echo “转出成功”; }else{ throw new PDOException(“转出失败！”)； } $affect_out=$pdo-&gt;exec(“update demo set ye=ye+{$price} where id =2”);//转入 if($affect_out){ echo “转入成功”; }else{ throw new PDOException(“转入失败！”)； } $pdo-&gt;commit();//提交以上事务 如有错误 转入PDO Exception异常处理； 手动抛出PDOException异常 throw new PDOException(“转入失败！”)；如果捕捉到异常就$pdo-&gt;rollback();","tags":[{"name":"事务处理","slug":"事务处理","permalink":"http://blog.psonlyweb.cn/tags/事务处理/"}]},{"title":"“设计模式之工厂模式 抽象工厂”","date":"2017-12-26T07:59:38.000Z","path":"2017/12/26/设计模式之工厂模式 抽象工厂/","text":"设计模式之工厂模式 抽象工厂多个类具有相同的属性和方法 1.首先声明类 class Mysql { } class Sqlite { } class MyPdo { } 2.建立一个工厂类接口，工厂类中可以声明属性和方法 interface Factory { public static function getDB(); } 3.然后声明抽象工厂类 实现工厂类接口中的静态方法 class MysqlFactory implements Factory { public static function getDB() { return new Mysql(); } } class MyPdoFactory implements Factory { public static function getDB() { // TODO: Implement getDB() method. return new MyPdo(); } } class MysqlliteFactory implements Factory { public static function getDB() { // TODO: Implement getDB() method. return new Sqlite(); } } 4、最后调用工厂类中的静态方法 $factory = &#39;MysqlFactory&#39;; $db = $factory::getDB(); print_r($db);","tags":[{"name":"抽象工厂","slug":"抽象工厂","permalink":"http://blog.psonlyweb.cn/tags/抽象工厂/"}]},{"title":"“事务处理封装方法 Thinkphp”","date":"2017-12-26T07:59:17.000Z","path":"2017/12/26/事务处理封装方法 Thinkphp/","text":"/** * @param $sqls 执行语句数组 * @return bool 返回真假 是否执行成功 */ public function transExecuteSql($sqls) { $this-&amp;gt;startTrans(); if(is_array($sqls)) { foreach($sqls as $k =&amp;gt; $sql) { $result=$this-&amp;gt;db-&amp;gt;execute($sql); if(!$result) { $this-&amp;gt;rollBack(); return false; } } }else{ $result=$this-&amp;gt;db-&amp;gt;execute($sqls); if(!$result) { $this-&amp;gt;rollBack(); return false; } } $this-&amp;gt;commit(); return true; }","tags":[{"name":"事务处理","slug":"事务处理","permalink":"http://blog.psonlyweb.cn/tags/事务处理/"}]},{"title":"“JS设计模式之观察者模式”","date":"2017-12-26T07:58:16.000Z","path":"2017/12/26/设计模式之观察者模式/","text":"设计模式之观察者模式 &lt;script&gt; var sel =document.getElementById(&#39;sel&#39;); sel.observes =[]; sel.attach =function (obj) { sel.observes[sel.observes.length] = obj; }; sel.detach = function (obj) { for( var i=0; i &lt; sel.observes.length; i++) { if(this.observes[i] == obj) { delete this.observes[i]; } } }; sel.onchange = sel.notify =function () { for( var i=0; i &lt; sel.observes.length; i++) { // this.observes[i].update(this); } }; var test2 = document.getElementById(&#39;test2&#39;); var test3 = document.getElementById(&#39;test3&#39;); test3.update = function (sel) { if(sel.value == &#39;1&#39;){ this.innerHTML = &#39;2&#39;; } else if(sel.value == &#39;0&#39;) { this.innerHTML =&#39;a&#39;; } }; test2.update = function (sel) { if(sel.value == &#39;1&#39;){ this.innerHTML = &#39;1&#39;; } else if(sel.value == &#39;0&#39;) { this.innerHTML =&#39;s&#39;; } }; sel.attach(test2); sel.attach(test3); &lt;/script&gt;","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.psonlyweb.cn/tags/JS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.psonlyweb.cn/tags/设计模式/"}]},{"title":"“JQ 1.6 获取属性 prop方法”","date":"2017-12-26T07:58:00.000Z","path":"2017/12/26/JQ 1.6 获取属性  prop方法/","text":"在JQ1.6之前的版本，我们会这样写我们的代码： &lt;input type=‘checkbox’ id=‘cb’/&gt; &lt;script&gt; //获取是否选中 var isChecked = $(‘#cb’).attr(‘checked’);5.6. //设置选中 $(‘#cb’).attr(‘checked’,true); &lt;/script&gt;可是当我们升级JQ1.6到更高的版本时，问题就来了，此时我们会发现：$(‘#cb’).attr(‘checked’); 返回的是checked或者是undefined，不是原来的true和false了。 并且checked属性在页面初始化的时候已经初始化好了，不会随着状态的改变而改变。所以如果checkbox一开始是选中的，那么返回的是checked，如果一开始没被选中，则返回的是undefined 它将“属性”与“特性”做了区别，属性指的是“name，id”等等，特性指的是“selectedIndex, tagName, nodeName”等等。JQ1.6之后，可以通过attr方法去获得属性，通过prop方法去获得特性 $(“#cb”).attr(“tagName”); //undefined $(“#cb”).prop(“tagName”); //INPUT","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.psonlyweb.cn/tags/JS/"}]},{"title":"移动设备上设置原始大小显示和是否缩放声明","date":"2017-12-26T07:57:52.000Z","path":"2017/12/26/移动设备上设置原始大小显示和是否缩放声明/","text":"在页面的头部&lt;head&gt;&lt;/head&gt;之间加上下面语句： &lt;meta name=”viewport” content=”width=device-width;initial-scale=1.0”/&gt; 或者&lt;meta name=”viewport” content=”width=600px”/&gt; &nbsp; &nbsp; &nbsp;","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.psonlyweb.cn/tags/HTML/"}]},{"title":"PDO中执行语句的exec()和query()区别","date":"2017-12-26T07:57:34.000Z","path":"2017/12/26/PDO中执行语句的exec()和query()区别/","text":"1、 exec() 用来处理非结果集的 Insert update delete create 等 返回影响行数 如果是插入语句可以使用id $pdo-&gt;lastinsertid();获取最后增加的id &nbsp; 2、query() 用来处理有结果集的语句 select desc show 例： $result=$pdo-&gt;query(“select * From student”); 返回来的是 PDOstatement类的对象，在通过这个类的方法获取结果，也可以直接foreach遍历结果但不常用 &nbsp; 如果要设置utf8编码集 set names utf8 $pdo-&gt; query(“set names utf8”); 等同于$pdo-&gt;exec(“set names utf8”); &nbsp; &nbsp; &nbsp;","tags":[{"name":"PDO","slug":"PDO","permalink":"http://blog.psonlyweb.cn/tags/PDO/"}]},{"title":"PDO的预处理语句","date":"2017-12-26T07:57:15.000Z","path":"2017/12/26/PDO的预处理语句/","text":"预处理的好处？效率要提高 安全性更好 建议：使用这种方式去执行Sql语句 PDO预处理删除、更新、添加语句： //只是将这个语句放在数据库中编译后等待,没有执行$stmt=$pdo-&gt;prepare(“insert into px_shopscore(pid,score)values(？,？)”);// 为问号参数 $stmt=$pdo-&gt;prepare(“insert into px_shopscore(pid,score)values(:pid,:score)”);// 为字符串参数,冒号是必须的 //绑定参数将问号或字符串与变量进行绑定 $stmt-&gt;bindParam(1,$pid);$stmt-&gt;bindParam(2,$score); 方式2 //绑定参数：为可选参数 $stmt-&gt;bindParam(“:pid”,$pid);$stmt-&gt;bindParam(“:score”,$score); //执行上面的数据库语句,执行语句之前给变量赋值 $pid=2;$score=3; //简化操作execute（）中传入数组（关联数组或者索引数组），对应字符串参数和？参数$stmt-&gt;execute(); PDO预处理查询语句： $stmt=$pdo-&gt;prepare(“select * from px_shopscore”); $stmt-&gt;execute(); //设置结果的模式，以下的代码都使用fetch()或fetchAll都是用这个模式 $stmt-&gt;setFetchMode(_PDO::FETCHNUM); //获取单条语句 while($row=$stmt-&gt;fetch()){ print_r($row); } fetch传值可以获取索引关联数组 &nbsp;* _PDO::FETCHASSOC：返回一个索引为结果集列名的数组 _PDO::FETCHBOTH（默认）：返回一个索引为结果集列名和以0开始的列号的数组 _PDO::FETCHNUM：返回一个索引为以0开始的结果集列号的数组fetchAll()获取整张表的数据（生成二维数组） //绑定栏目(同bindParam) $stmt-&gt;bindColumn(1,$pid); $stmt-&gt;bindColumn(2,$score); 返回受上一个 SQL 语句影响的行数 PDOStatement::rowCount — 返回受上一个 SQL 语句影响的行数$stmt-&gt;rowCount();获取增加idPDO::lastInsertId;","tags":[{"name":"PDO","slug":"PDO","permalink":"http://blog.psonlyweb.cn/tags/PDO/"}]},{"title":"mysql主从复制","date":"2017-12-26T07:56:16.000Z","path":"2017/12/26/mysql主从复制/","text":"mysql主从复制 一、 配置主服务器 编辑my.cnf文件 默认位置一般在/etc下 在[mysqld]的下面加入下面代码： log-bin=mysql-bin server-id=1 innodb_flush_log_at_trx_commit=1 sync_binlog=1 binlog-do-db=wordpress//表明备份哪个数据库 binlog_ignore_db=mysql //表明忽略mysql库的备份 2.重启mysql service mysqld restart 3.连接mysql数据库 mysql -u root -p 4.在主服务器上创建用户并赋予”REPLICATION SLAVE”权限 x.x.x.x为 从属服务器ip 已授权的方式创建用户 GRANT REPLICATION SLAVE -&gt; ON *.* -&gt; TO &#39;ps&#39;@&#39;192.168.199.118&#39; -&gt; IDENTIFIED BY &#39;123456&#39;; 5.执行以下命令锁定数据库以防止写入数据。 mysql&gt;FLUSH TABLES WITH READ LOCK; 6.导出数据库备份文件 mysqldump -u root -p --databases work --lock-tables=false &gt; all.sql //lock-tables 是否锁定数据表 //databases 数据库名 7.用scp命令传输数据库文件all.sql到从服务器 scp all.sql root@192.168.199.118:/root [注意:] scp命令使用时 主服务器和从服务器都要安装 openssh-clients yum install -y openssh-clients ssh -v //查看服务器上是否有openssh-clients 8.连接mysql数据库 进入mysql命令行查看master状态 mysql&gt; SHOW MASTER STATUS; +------------------+----------+--------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +------------------+----------+--------------+------------------+ | mysql-bin.000001 | 260 | work | mysql | +------------------+----------+--------------+------------------+ 9.解锁数据表 mysql&gt; UNLOCK TABLES; 二、 配置从属数据库 1.导入主数据库数据表 mysql -u root -p work &lt; all.sql [注释] &lt; 导入 &gt; 导出 2.编辑my.cnf,在[mysqld]下面加入 server-id=2 可以自己定义,保证唯一 3.登录mysql服务器，执行以下命令。 mysql&gt; CHANGE MASTER TO -&gt; MASTER_HOST=&#39;192.168.199.163&#39;, -&gt; MASTER_USER=&#39;ps&#39;, -&gt; MASTER_PASSWORD=&#39;123456&#39;, -&gt; MASTER_PORT=3306, -&gt; MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;, -&gt; MASTER_LOG_POS=260, -&gt; MASTER_CONNECT_RETRY=10; [注意:] MASTER_HOST:主服务器的IP。 MASTER_HOST:主服务器的IP。 MASTER_USER：配置主服务器时建立的用户名 MASTER_PASSWORD：用户密码 MASTER_PORT：主服务器mysql端口，如果未曾修改，默认即可。 4.启动slave进程。 START SLAVE;//开启SLAVE进程 show slave status\\G //查看SLAVE进程状态 [注意]连接不上mysql数据库 有可能是防火墙的原因 service iptables stop","tags":[{"name":"主从复制","slug":"主从复制","permalink":"http://blog.psonlyweb.cn/tags/主从复制/"}]},{"title":"“angularJS里的$http.post传数据到php接收问题”","date":"2017-12-26T07:55:16.000Z","path":"2017/12/26/angularJS里的$http.post传数据到php接收问题/","text":"有两种方式解决这个问题： 1.简单粗暴的直接改成$.post()方法，这样后台不用作任何修改，但是网上一些比较有经验的网友称这样可能违背使用angular的初衷。 2.修改php代码 $postData = file_get_contents(‘php://input’, true); $obj=json_decode($postData); $query1 = “SELECT * FROM role_roleRight WHERE roleId=$obj-&gt;rr”;","tags":[{"name":"angularJS","slug":"angularJS","permalink":"http://blog.psonlyweb.cn/tags/angularJS/"}]},{"title":"“单例模式”","date":"2017-12-26T07:53:42.000Z","path":"2017/12/26/设计模式之单例模式/","text":"设计模式之单例模式 &lt;?php class Single { protected $rnd; protected static $ins =null ; //将自动加载 设置为 protected类型 //这样没法new 类名进行实例化 protected function __construct() { $this-&gt;rnd =rand(0,1000); } //声明一个静态方法 public static function getins(){ //判断self::$ins 保存着实例化之后的对象 if (self::$ins == null) { self::$ins = new self(); } return self::$ins; } } ?&gt;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.psonlyweb.cn/tags/PHP/"},{"name":"单例模式","slug":"单例模式","permalink":"http://blog.psonlyweb.cn/tags/单例模式/"}]},{"title":"拥有相同字段值的记录某个字段合并","date":"2017-12-26T07:48:43.000Z","path":"2017/12/26/拥有相同字段值的记录某个字段合并/","text":"想生成上面的数据将门诊科室进行合并 使用 group_concat(合并字段) group by 唯一标识这种方式可以实现","tags":[]},{"title":"编译安装PHP扩展","date":"2017-12-26T07:30:47.000Z","path":"2017/12/26/编译安装PHP扩展/","text":"编译安装PHP扩展1、下载PHP环境安装包 php-7.1.42、解压php安装包tar -zxf php-7.1.4.tar.gz3、进入ext和你要安装的扩展的目录4、执行phpize/usr/local/php7-bht/bin/phpize5、执行编译命令 ./configure --with-php-config=/usr/local/php7-bht/bin/php-config --with-curl=DIR ps: –with-curl 根据安装扩展不同更改 6、执行 make &amp;&amp; make install 7、然后会生成扩展名.so的文件目录在extensions下 /usr/local/php7-bht/lib/php/extensions/no-debug-non-zts-20160303/ 8、执行加载模块 /usr/local/php/bin/php -m |grep curl","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.psonlyweb.cn/tags/Linux/"},{"name":"PHP扩展","slug":"PHP扩展","permalink":"http://blog.psonlyweb.cn/tags/PHP扩展/"}]},{"title":"“插入排序”","date":"2017-10-09T05:25:11.000Z","path":"2017/10/09/“插入排序”/","text":"PHP实现插入排序算法&lt;?php function insert_sort($arr){ for ($i=1;$i&lt;count($arr);$i++){ $key=$arr[$i]; $j=$i-1; //插入排序判断条件 while($j&gt;=0 &amp;&amp; $arr[$j]&gt;$key){ $arr[$j+1]=$arr[$j]; $j=$j-1; } $arr[$j+1]=$key; } return $arr; } $arr= array(5,2,4,6,1,3); $arr=insert_sort($arr); var_dump($arr); ?&gt; 循环不变式（理解算法的正确性）循环不变式的三条性质： 初始化：循环的第一次迭代之前，它为真 保持：如果循环的某次迭代之前他为真，那么下一次迭代之前它仍为真。 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质是用于证明算法是正确的。利用循环不变式证明插入排序是正确的 初始化:当$i=2时，进入循环，$i=2所在数组元素前只有一个A[1]，因为只有一个元素，那么这个判断之前，该数组一定是有序的。 保持:第二条性质，当第一次循环执行下来，A[1]与A[2]进行比较，A[1],A[2]按照由小到大进行排列，保持了初始化中的性质，循环到$i为任意值，那么循环过后1-j一定是有序的，保持数组是有序的性质。 终止：循环终止的条件是i &gt; 数组.length = n,因为每次循环i都会增加1，最终 1-n一定是有序排列的。总结插入一个数据之前，所在位置n之前的数据一定是有序排列的。 插入排序最坏运行时间为n² 最好的运行时间为n 那么该数组一定是有序的。","tags":[{"name":"排序","slug":"排序","permalink":"http://blog.psonlyweb.cn/tags/排序/"}]}]